#pragma once

#include <memory>

#include "inter.h"
#include "lexer.h"
#include "symbol_table.h"

/**
 * @brief The Parser class implements a recursive descent parser for the
 * language.
 *
 * The parser constructs an abstract syntax tree (AST) from the input tokens
 * generated by the Lexer.
 */
class Parser {
public:
    /**
     * @brief Constructs a Parser for the given input file.
     * @param file_name Path to the source file to parse.
     */
    Parser(const std::string& file_name);

    /**
     * @brief Parses the entire program.
     * @return Root node of the generated AST.
     */
    std::unique_ptr<Stmt> program();

    /**
     * @brief Parses a block enclosed in curly braces.
     * @return AST node representing the block.
     */
    std::unique_ptr<Stmt> block();

    /**
     * @brief Parses variable declarations at the start of a block.
     */
    void decls();

    /**
     * @brief Parses a sequence of statements.
     * @return AST node representing the statement sequence.
     */
    std::unique_ptr<Stmt> stmts();

    /**
     * @brief Parses a type specification.
     * @return Type object representing the parsed type.
     */
    std::unique_ptr<Type> type();

    std::unique_ptr<Type> dims(std::unique_ptr<Type> t);

    /**
     * @brief Parses a single statement.
     * @return AST node representing the statement.
     */
    std::unique_ptr<Stmt> stmt();

    /**
     * @brief Parses an expression.
     * @return AST node representing the expression.
     */
    std::unique_ptr<Expr> expr();

    /**
     * @brief Parses an assignment statement.
     * @return AST node representing the assignment.
     */
    std::unique_ptr<Stmt> assign();

    /**
     * @brief Parses a term (multiplicative operations).
     * @return AST node representing the term.
     */
    std::unique_ptr<Expr> term();

    /**
     * @brief Parses a unary expression.
     * @return AST node representing the unary expression.
     */
    std::unique_ptr<Expr> unary();

    /**
     * @brief Parses a factor (basic expression components).
     * @return AST node representing the factor.
     */
    std::unique_ptr<Expr> factor();

private:
    Lexer lex_;  ///< Lexical analyzer for token generation.
    std::unique_ptr<Token> next_token_;  ///< Lookahead token.
    std::shared_ptr<STable> top_table_;  ///< Current symbol table scope.

    /**
     * @brief Advances to the next token in the input stream.
     */
    void next();

    /**
     * @brief Checks if the current token matches the expected type.
     * @param tok Expected token tag.
     * @note Prints validation result to stdout.
     */
    void match(unsigned int tok);

    /**
     * @brief Matches the current token and advances to the next one.
     * @param tok Expected token tag.
     */
    void match_and_move(unsigned int tok);
};